<!DOCTYPE html>


<head>

    <meta charset="utf-8">
    <meta name="description" content="WebRTC code samples">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
    <meta itemprop="description" content="Client-side WebRTC code samples">
    <meta itemprop="image" content="../../../images/webrtc-icon-192x192.png">
    <meta itemprop="name" content="WebRTC code samples">
    <meta name="mobile-web-app-capable" content="yes">
    <meta id="theme-color" name="theme-color" content="#ffffff">

    <base target="_blank">

    <title>captureStream(): video transcoder, muxer, assembler. </title>
    <link rel="icon" sizes="192x192" href="../../../images/webrtc-icon-192x192.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata&family=Philosopher&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Unica+One" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="css/main2.css" />
    <div class="container">
        <h1 class="heading" data-target-resolver></h1>
        <script src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>
        <style>
            * {
                box-sizing: border-box;
            }
            
            html,
            body {
                height: 30%;
                margin: 10;
                font-family: 'Philosopher', sans-serif;
                text-transform: uppercase;
                background: #242323;
            }
            
            html,
            header {
                height: 30%;
                margin: 55px;
                font-family: 'Philosopher', sans-serif;
                background: #242323;
                color: #eeeeee;
            }
            
            .container {
                display: flex;
                align-items: center;
                justify-content: center;
                height: 25%;
                padding: 15rem;
            }
            
            .flex-container-header {
                display: flex;
                flex-direction: row;
                height: 200px;
                align-items: flex-start;
                justify-content: space-between;
            }
            
            .flex-container {
                display: flex;
                flex-direction: row;
                flex-flow: row wrap;
                height: 200px;
                align-items: center
            }
        </style>

</head>
<header>
    <div class="flex-container-header"></div>
</header>

<body>


    <script type="text/babel">
        const resolver = { resolve: function resolve(options, callback) { // The string to resolve const resolveString = options.resolveString || options.element.getAttribute('data-target-resolver'); const combinedOptions = Object.assign({}, options, {resolveString:
        resolveString}); function getRandomInteger(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }; function randomCharacter(characters) { return characters[getRandomInteger(0, characters.length - 1)]; }; function doRandomiserEffect(options,
        callback) { const characters = options.characters; const timeout = options.timeout; const element = options.element; const partialString = options.partialString; let iterations = options.iterations; setTimeout(() => { if (iterations >= 0) { const
        nextOptions = Object.assign({}, options, {iterations: iterations - 1}); // Ensures partialString without the random character as the final state. if (iterations === 0) { element.textContent = partialString; } else { // Replaces the last character
        of partialString with a random character element.textContent = partialString.substring(0, partialString.length - 1) + randomCharacter(characters); } doRandomiserEffect(nextOptions, callback) } else if (typeof callback === "function") { callback();
        } }, options.timeout); }; function doResolverEffect(options, callback) { const resolveString = options.resolveString; const characters = options.characters; const offset = options.offset; const partialString = resolveString.substring(0, offset);
        const combinedOptions = Object.assign({}, options, {partialString: partialString}); doRandomiserEffect(combinedOptions, () => { const nextOptions = Object.assign({}, options, {offset: offset + 1}); if (offset
        <=r esolveString.length) {
            doResolverEffect(nextOptions, callback); } else if (typeof callback==="function" ) { callback(); } }); }; doResolverEffect(combinedOptions, callback); } } /* Some GLaDOS quotes from Portal 2 chapter 9: The Part Where He Kills You * Source: http://theportalwiki.com/wiki/GLaDOS_voice_lines#Chapter_9:_The_Part_Where_He_Kills_You
            */ const strings=[ '10', '9', '8', '7', '6', '5', '4', '3', '2', '1', '..' ] let counter=0; const options={ // Initial position offset: 0, // Timeout between each random character timeout: 5, // Number of random characters to show iterations:
            17, // Random characters to pick from characters: [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'x', 'y', 'x', '#', '%', '&', '-', '+', '_', '?', '/', '\\' ] // String to resolve
            ,resolveString: strings[counter], // The element element: document.querySelector( '[data-target-resolver]') } // Callback function when resolve completes function callback() { setTimeout(()=> { counter ++; if (counter >= strings.length) { counter = 0; } let nextOptions = Object.assign({}, options, {resolveString: strings[counter]}); resolver.resolve(nextOptions, callback); }, 1000); } resolver.resolve(options, callback);
    </script>


    </div>

    <div class="flex-container">
        <h1><span>CaptureStream: Source video to streaming video.</span><br> Left: mp4 or webm file (source) Right: A fully rendered, ultra-low latency WebRTC stream</h1>
    </div>
    </div>
    <div class="flex-container">

        <script src="js/main.js"></script>
</body>

</html>